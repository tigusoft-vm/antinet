
(C) 2016 Antinet.org Team

All this text is copyrighted as part of Antinet project (e.g.:GPLv3, but see Antinet project licence).



!!! This is a draft. It can contain still mistakes, ERRORS, and will likelly be changed in future. !!!



=== Summary of available crypto systems ===
Intro: General summary of crypto available that we COULD use:

Things Vulnerable to QC are marked as <vulnQC>.
Things thought to be resistant to QC are marked as <resistant>.
Hash and SymEncrypt (including SymAuth) are immune to QC.

NTru ---> NTru-Sign PubSign/Chain <resistant>
      '-> NTru-Encr PubEncrypt <resistant>

RSA<vulnQC> (PubSign, PubEncrypt)

EdDSA (PubSign) --------> Ed25519 <vulnQC>
                             ^
                             | because Schnorr
                             v
                  ,---> Curve25519 "X25519" (KeyAgr) <vulnQC>
                  |
DH (KeyAgr) ---> ECDH <vulnQC>
                  |
                  '---> SIDH <resistant> (KeyAgr)

SHA* (Hash)
  |--> Contest NSA ---> SHA-1 --> SHA1
  |
  |--> Contest NSA ---> SHA-2 --> SHA256, SHA512
  |
  '--> Contest NIST ---> Winner ---> Keccak -!-!-> ! SHA-3 (reduced strength?)
               |
               '--> Others ---> Blake <..................
                                                        . blake uses chacha20
                                                        .
                                                        .
AES (SymEncrypt, SymAuth) ~~~~~~> Salsa20 (older) ---> ChaCha20

Hash based crypto ---> Lamport ---> Geport

Poly1305 (HMAC)

BlockChain ------> BC+PoW
   |
   '---> CoinSign

Cjdns (v17) uses:
1) Establish CryptoAuth session - DHDH (X25519 permanent + X25519 ephemeral)
2) Each packet: Poly1305 Salsa20

=== Galaxy42 crypto - overview ===

Galaxy uses following crypto:

For given connection we create a tunnel (for end-to-end session,
and other for peer-to-peer session):

based on session secret K, we symmetrically encrypt and authorize.
More exactly: using Salsa20 and Curve 1305.

This part is very secure against QC and other attacks.
The problem is how to establish K in secure way (next chapter).


=== Galaxy42 crypto - establishing secure session K ===

How to establish the secret K - in a way resistant to QC?
(For comparsion as of 2016-04, Cjdns v17 that uses ECDH X25519 it is NOT resistant to QC attacks).

We use Diffie-Hellman like key exchange & also we use symmetrical crypto;
Both methods protect eachother recursively.
So we use:

DH & SymHash - and more exactly it is:
DHDH & SymHash - and more exactly it is:
ECDH+ECDH & AES+HASH - and more exactly it is:
X25519+X25519 & Salsa20+BLAKE2

But we also use DH-like key exchange with NTru encrypt/sign optionally:

Xchg-Pubkey[NTru-encrypt] and X25519+X25519  &  Salsa20+BLAKE2

These 3 parts can establish 3 shared keys that then are combined into the K shared key.
If any of them resists attacks, then entire system resisted too.

1. Xchg-Pubkey[NTru-encrypt] - probably resistant to QC.
2. X25519+X25519 - not resistant to QC, but good otherwise.
3. Salsa20+BLAKE2 - resistant to QC by definition, and secure and well tested.

Problem with 3 is that it can not be established between two IPv6 directly as it requires exchange of
another password over secure channel first.
If ANY of previous session was not broken by attacker, e.g. was not monitored by attacker,
then we are safe - since in each we exchange and add the symmetrical
passwords (we keep hashed state known as Historical Password).
We offer 3 solutions:
1. Not observed - we can hope attacker did not archived ALL of Alice conversations to given Bob.
2. Manual - Alice and Bob could at some point meet to protect future transmissions.
3. Not broken - if either DH or NTru holds then after such exchange transmissions are safe.
This is interesting in case if NTru will turn out to be sometimes breakable and sometimes not, based on
today yet unknown mathematical property of given key.

--- Xchg-Pubkey ---

Is a secret key agreement protocol between parties that know each-other public key already,
using assymetrical crypto.

Alice has pubkey PubA ( == the virtual IP)
Bob has pubkey PubB ( == the virtual IP)
Alice ra=random(), encrypts ra to PubB, sends to Bob.
Bob   rb=random(), encrypts rb to PubA, sends to Alice.
Alice: K = ra xor rb
Bob:   K = ra xor rb
 or instead (maybe better):
K = H( H(ra) xor H(rb) xor H(ra xor rb) ) // todo? does it decrease chance of...
// ...other  side to in any way predict anything about K?

Xchg-Pubkey[NTru-encrypt] is above, using NTru Encrypt as the assymetrical encryption.

=== Galaxy42 crypto - loading the main key ===

We need main key(s).
For example (as in Cjdns v17) a permanent X25519 key.
We call that key the runtime key (e.g. runtime DH = runtime X25519 key).

But we also use other stages of the key - see in chapter "Key levels".

=== Galaxy42 crypto - key levels ===

Alice's vault --- (for PubSign) key Vault - offline computer, saved on disk
Alice's issuer --- (for PubSign) key Issuer - other computer (e.g. offline), saved on disk
Alice's installation --- (for PubSign) key Program - this computer, disk, and this process on startup ONLY!
Alice's program runs --- (for *DH) key Runtime - memory only (same for all users), generated on startup
CA session (to Bob) --- (for *DH) key Temporary/ephemeral - memory only (generated for each user / CA reset)

For each session the program generates temporary/ephemeral key;
And authenticates it by encrypting temporary key to some shared key password1 (and optionaly some
confirmation string like a constant or maybe Poly1305)
and this password1 was agreed upon by exchange X25519 between Alice (and Bob's) runtime key.

The runtime key is again confirmed, by being signed (PubKey sign this time, e.g. with Ed25519),
by the installation key.

Installation key can be optionally signed by issuer key.
Issuer key can be optionally signed by vault key.

The IPv6 hash is create by the highest key: that is by vault key if it exists, else by issuer, else by installation.

Above steps allow to regain controll of IPv6 address after e.g. entire program runtime memory was compromised [Instalation
recovers that],
or when entire installation machine (e.g. a server) was compromised [then Issuer fixes that],
or even when Issuer was compromised (the Vault).

Keys have validity periods, and define the time for the key they sign.

Example:

Vault key 0x99998888 (valid forever) is created;  It's hash defines the IPv6 e.g. fd42cafe4242
Issuer generates key 0x7777.
Vault signs: "key 0x7777 is valid since 2016-01-01 for 744 hours".
Install generates key 0x5555.
Issuer signs: "key 0x5555 is valid since 2016-01-01 for 50 hours".

When program starts, it generates and hold in memory a runtime key 0x4444.


Example:


           K for ChaCha20 + Poly1305
           ^
           |
         / | \
        /  |  \
K-Ntru  N-DHDH  K-SymHash


For each: K-Ntru, K-DHDH - we load them by delegated steps:


K-*-Alice-tmp, is generated, and then encrypted with K-*-Alice-runtime.
Therefore key "runtime" is what we called "permanent" in "DHDH" (DH plus ephemeral; DH PFS)

        K-*-tmp for example K-DHDH this is the temporary (ephemeral) key
        ^
        |
     ENCRYPT(+auth by adding constant string) <---- encrypt to password1
        |                         |
  generate_X25519()               |
                                  | from DH exchange with pubkey
                                  |
                         DH to pubkey K-*-runtime
                                  ^
                                  |
                           generate_X25519() on program startup
                                  ^
                                  |
Sign that key with                |
the 25519 "Installation" ------ PubSign { crypto_scalarmult_base ? }
Key form disk.
     ^
     |
  PubSign <---- signed by Issuer Key
                              ^
                              |
                          signed by Vault key



=== Galaxy42 crypto - all ===

All together, the big picture.

Shortcut names for crypto systems used below:

X     = X25519 (type of ECC) pubkey for key agreement.
E     = Ed25519 (type of ECC) pubkey for pubsig.
NT    = NTru (lattice-based, likely QC resistant) pubkey (for sign and for encry).
Ge    = Geport (Lamport variant, almost certainly QC resistant) pubsig. Includes the tree of signatures as needed.

Mode name    | IPv6        | Vault | Issuer | Install | Runtime  | ephemeral | Packet(K)
-------------|-------------+-------+--------+---------+----------+-----------|---------
Cjdns        |Hash1(X)     |       |        | X       | =install | X         | Curve1305+Salsa20
Galaxy turbo |Hash2(Vault) | E+NT  |        | X       | =install | X         | Curve1305+ChaCha20
Galaxy fast  |Hash2(Vault) | E+NT  | E+NT   | E+NT    | X+NT     | X+NT      | Curve1305+ChaCha20
Galaxy bank  |Hash2(Vault) |E+NT+Ge|E+NT+Ge | E+NT    | X+NT     | X+NT      | Curve1305+ChaCha20

Hash1(m) = truncate_to(512, SHA512(SHA512(m)))
Hash2(m) could be = Hash1(m) or else:
<<optional>> Hash2(m) = compress4( SHA3x(SHA3x(SHA3x( m ))) )

Compress4 generates an (n/4)-bit output "y" from n-bit input "x", as: y[i/4] = x[i] ^ x[i+1] ^ x[i+2] ^ x[i+3]

--- Full example ---

Generate IP:
  generate keypair NTru
  generate keypair Ed25519
  generate keypair Geport<Blake2>


=== IP hashing type ===

<< optional ? >>

IP type 0: IPv6 is hash sha512 of: (DH master key)
IP type 1: IPv6 is hash ...... of: (DH master key) and (NTru master key - used for encryption)
IP type 2: IPv6 is hash ...... of: Lamport master root key. It will sign: DH master key, NTru master key
and will allow to in future change to other algorithms (tree of Lamport signatures).
IP type 3: is reserved for future use.

IPv6 type is encoded in the IPv6 bit number 60 and 61.
The IPv6 of given type is generated by rules of given type untill the bits 60 and 61 happen to correctly
encode the desired IP type, e.g. will be "01" for IP type 1.


=== Details ===

DH-DH exchange:


On ID creation:
Ali: ap,AP = Generte_DH // make permanent keys: ap = Ali_DH_Perm_priv , AT = Ali_DH_Perm_Pub

On ID creation:
Bob: bp,BP = Generte_DH // same for Bob



On CA establishing from Alice to Bob:
Alice:
  at,AT = Generte_DH() // make temporary keys: at = Ali_DH_Tmp_priv , AT = Ali_DH_Tmp_Pub
  r1 = credentials_given_by_b || ';' || secure_random
  mt = "AT,r1"; // message with temporary key and temporary random

  KP = complete_DH( ap , BP ) , () // prepare permanent-key based AuthEncr
  uap=secure_random() ; ua = uap || encrypt_symm( KP , uap || mt ) // authenticate temp message

Ali -> Bob: "ua" // NETWORK send

Bob:
  decrypts/checks auth: ua
  has AT, r1

  bt,BT = Generte_DH() // make temporary keys: at = Ali_DH_Tmp_priv , AT = Ali_DH_Tmp_Pub
  r2 = secure_random()
  mt = "BT,r2"; // message with temporary key and temporary random

  KP = complete_DH( bp , AP ) , // prepare permanent-key AuthEncr
  ubp=secure_random() ; ub = ubp || encrypt_symm( KP , ubp || mt ) // authenticate temp message
  ... or ub = encrypt_symm( KP , ubp || ubp || mt )
  ... or ub = encrypt_symm( KP , 'all_is_fine' || mt )

Bob -> Alice: "ub" // NETWORK send

Alice:
  decrypts/checks auth: ub
  has BT, r2

Now both sides calculate the same:
  TSK = complete_DH( at , BT) or = complete_DH( bt , AT) // Temporary Shared Key
  FSSSK = H( H( TSK ) || H( r1 ) || H( r2 ) ) // Forward-Secrecy Session Shared Key
  nonce=1



*** r1,r2 helps when:
attack hardness: badluck-DH << DH-tmp , DH-perm


***
break: bp - bob permanent privkey
impersonate bob: BT' <-- attackers key


=== TODO ===


--- Curve25519 exceptions ---
Q: Is this relevant to any use?

How do I validate Curve25519 public keys? [ https://cr.yp.to/ecdh.html ]
"
Don't. The Curve25519 function was carefully designed to allow all 32-byte strings as Diffie-Hellman public keys. Relevant lower-level facts: the number of points of this elliptic curve over the base field is 8 times the prime 2^252 + 27742317777372353535851937790883648493; the number of points of the twist is 4 times the prime 2^253 - 55484635554744707071703875581767296995. This is discussed in more detail in the curve25519 paper.

There are some unusual non-Diffie-Hellman elliptic-curve protocols that need to ensure ``contributory'' behavior. In those protocols, you should reject the 32-byte strings that, in little-endian form, represent 0, 1, 325606250916557431795983626356110631294008115727848805560023387167927233504 (which has order 8), 39382357235489614581723060781553021112529911719440698176882885853963445705823 (which also has order 8), 2^255 - 19 - 1, 2^255 - 19, 2^255 - 19 + 1, 2^255 - 19 + 325606250916557431795983626356110631294008115727848805560023387167927233504, 2^255 - 19 + 39382357235489614581723060781553021112529911719440698176882885853963445705823, 2(2^255 - 19) - 1, 2(2^255 - 19), and 2(2^255 - 19) + 1. But these exclusions are unnecessary for Diffie-Hellman.
"





